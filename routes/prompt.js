const express = require('express');
const router  = express.Router();
const { getPool } = require('../database/init');
const { generateText, generateJSON } = require('../utils/llm');

async function getDefaultClientId() {
  const db = getPool();
  const { rows } = await db.query(`SELECT id FROM clients WHERE is_default=TRUE ORDER BY id LIMIT 1`);
  return rows[0]?.id || (await db.query('SELECT id FROM clients ORDER BY id LIMIT 1')).rows[0]?.id;
}

async function getBrandKit(clientId) {
  const { rows } = await getPool().query('SELECT * FROM brand_kits WHERE client_id=$1', [clientId]);
  return rows[0] || null;
}

// Deterministic fallback prompt
function buildFallbackPrompt({ brandKit, campaignGoal, referenceStyle, productDesc }) {
  const parts = [];
  if (brandKit?.brand_name) parts.push(`${brandKit.brand_name} advertisement.`);
  if (productDesc)         parts.push(`Product: ${productDesc}.`);
  if (campaignGoal)        parts.push(`Goal: ${campaignGoal}.`);
  if (referenceStyle)      parts.push(`Style reference: ${referenceStyle}.`);
  if (brandKit?.primary_color) parts.push(`Primary color: ${brandKit.primary_color}.`);
  if (brandKit?.font_primary)  parts.push(`Font: ${brandKit.font_primary}.`);
  parts.push('Clean, professional, high-contrast static ad. Photorealistic product hero shot.');
  return parts.join(' ');
}

// POST /api/prompt/compose
router.post('/compose', async (req, res, next) => {
  try {
    const clientId = req.body.clientId || await getDefaultClientId();
    const { referenceStyle, productDesc, intelligenceProfileId, campaignGoal } = req.body;

    const brandKit = await getBrandKit(clientId);
    let profile = null;
    if (intelligenceProfileId) {
      const r = await getPool().query('SELECT * FROM brand_intelligence WHERE id=$1', [intelligenceProfileId]);
      profile = r.rows[0] || null;
    }

    const kitContext = brandKit
      ? `Brand: ${brandKit.brand_name || 'N/A'}. Colors: ${brandKit.primary_color}, ${brandKit.secondary_color}, ${brandKit.accent_color}. Font: ${brandKit.font_primary}. Tone: ${brandKit.brand_description || 'professional'}.`
      : '';

    const profileContext = profile
      ? `Target persona: ${profile.persona}. Pain point: ${profile.pain_point}. Angle: ${profile.angle}. Visual direction: ${profile.visual_direction}. Emotion: ${profile.emotion}. Copy hook: "${profile.copy_hook}".`
      : '';

    const aiPrompt = `
You are an expert static ad creative director. Write a single, precise image generation prompt for a static social media ad.

${kitContext}
${profileContext}
${referenceStyle ? `Reference style: ${referenceStyle}.` : ''}
${productDesc ? `Product/Subject: ${productDesc}.` : ''}
${campaignGoal ? `Campaign goal: ${campaignGoal}.` : ''}

Rules:
- Output ONLY the image generation prompt text. No markdown, no labels, no explanation.
- Be specific about lighting, composition, mood, color palette, and typography placement.
- The prompt must be executable by a text-to-image model.
- Max 200 words.
    `.trim();

    let composedPrompt;
    let usedFallback = false;
    let rationale = '';

    try {
      composedPrompt = await generateText(aiPrompt);
      rationale = 'Generated by Gemini AI based on brand kit and intelligence profile.';
    } catch (err) {
      console.warn('[PROMPT] Gemini failed, using fallback:', err.message);
      composedPrompt = buildFallbackPrompt({ brandKit, campaignGoal, referenceStyle, productDesc });
      usedFallback = true;
      rationale = 'Deterministic fallback used (Gemini unavailable).';
    }

    res.json({
      prompt: composedPrompt,
      rationale,
      usedFallback,
      model: process.env.GEMINI_MODEL || 'gemini-1.5-flash',
    });
  } catch (err) { next(err); }
});

// POST /api/prompt/reverse – reverse-engineer a winning ad image
router.post('/reverse', async (req, res, next) => {
  try {
    const { imageUrl, campaignGoal } = req.body;
    if (!imageUrl) return res.status(400).json({ error: 'imageUrl is required' });

    const aiPrompt = `
You are a creative strategist analyzing a winning static advertisement.

Analyze the provided ad image URL: ${imageUrl}
${campaignGoal ? `Campaign goal context: ${campaignGoal}` : ''}

Return a JSON object with:
{
  "style_prompt": "A precise image generation prompt capturing the visual style, lighting, composition, colors",
  "copy_skeleton": "The structural pattern of the ad copy (headline formula, CTA type, layout)",
  "variant_prompts": ["prompt variant 1", "prompt variant 2", "prompt variant 3"],
  "analysis": {
    "visual_style": "description",
    "color_palette": "description",
    "composition": "description",
    "audience_signals": "description"
  }
}

IMPORTANT: Do NOT copy competitor brand names, logos, or make literal factual claims. Focus on style and structure only.
    `.trim();

    const result = await generateJSON(aiPrompt);
    res.json(result);
  } catch (err) { next(err); }
});

// POST /api/prompt/concepts – generate multiple concept directions
router.post('/concepts', async (req, res, next) => {
  try {
    const clientId = req.body.clientId || await getDefaultClientId();
    const { referenceImageUrl, campaignGoal, numConcepts = 4 } = req.body;

    const brandKit = await getBrandKit(clientId);
    const kitContext = brandKit
      ? `Brand: ${brandKit.brand_name}. Colors: ${brandKit.primary_color}, ${brandKit.accent_color}. Tone: ${brandKit.brand_description || 'professional'}.`
      : '';

    const aiPrompt = `
You are a creative director generating diverse concept directions for a static ad campaign.

${kitContext}
${referenceImageUrl ? `Reference image: ${referenceImageUrl}` : ''}
${campaignGoal ? `Campaign goal: ${campaignGoal}` : ''}

Generate ${numConcepts} DISTINCT concept directions. For each return:
{
  "concept_type": "e.g. Lifestyle, Product Hero, Testimonial, Comparison, Emotional Story",
  "angle": "core message angle",
  "audience_stage": "awareness | consideration | conversion | retention",
  "why_distinct": "what makes this concept unique from the others",
  "prompt_template": "ready-to-use image generation prompt for this concept"
}

Return a JSON array of ${numConcepts} concept objects.
    `.trim();

    const concepts = await generateJSON(aiPrompt);
    const arr = Array.isArray(concepts) ? concepts : concepts.concepts || [];
    res.json({ concepts: arr });
  } catch (err) { next(err); }
});

module.exports = router;
